@grammar

Once you decide to extend the grammar, it is inconvenient to keep it in a script. 
It is a good practice to define a proper parser, because it allows us to
manage cyclic dependencies, 
simplify testing and 
easily extend with new functionality. 
We create a parser by subclassing ==PP2CompositeNode==:


[[[
PP2CompositeNode subclass: #WebGrammar
	instanceVariableNames: 'javascript'
	classVariableNames: ''
	package: 'PetitParser2-SeasTutorial'
]]]

We define a ==javascipt== rule as follows:

[[[
WebGrammar>>javascript
	^ jsOpen, jsContent, jsClose ==> #second
]]]

[[[
WebGrammar>>jsOpen
^ '<script>' asPParser

WebGrammar>>jsContent
	^ (jsString / any) starLazy


WebGrammar>>jsClose
	^ '</script>' asPParser


WebGrammar>>jsString
	^ $' asPParser, #any asPParser starLazy, $' asPParser


WebGrammar>>any
	^ #any asPParser
]]]


First, we would like to cover ==javascript== rule with some test to make sure the rule works as expected. 
We start by subclassing ==PP2CompositeParserTest==:

[[[
PP2CompositeNodeTest subclass: #WebGrammarTest
	instanceVariableNames: ''
	classVariableNames: ''
	package: 'PetitParser2-SeasTutorial'

WebGrammarTest>>parserClass
	^ WebGrammar


WebGrammarTest>>testJavascript
	self parse: '<script>alert("hi there!")</script>' rule: #javascript.	
]]]


To extract a javascript from an html document, we first define the ==document== rule simply as ==javascript== because we are interested only in javascript:

[[[
WebGrammar>>document
	^ javascript islandInSea star
]]]

The ==islandInSea== operator is just a shorthand for:
[[[
sea ==> #second
]]]

And finally we define the start rule as a document:

[[[
WebGrammar>>start
	^ document
]]]

And finally, we write a test for ==document==:

[[[
WebGrammarTest>>testDocument
	| input |
	input := PP2Sources current htmlSample.
	
	self parse: input rule: #document.
	Self assert: result size equals: 2.
]]]

The ==WebGrammar== and ==WebParser== can be downloaded here.
@@todo create a link.
